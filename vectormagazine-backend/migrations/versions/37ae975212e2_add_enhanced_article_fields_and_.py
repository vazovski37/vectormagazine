"""Add enhanced article fields and category model

Revision ID: 37ae975212e2
Revises: 9f3eb0cfb36a
Create Date: 2025-12-12 01:23:39.379522

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql
import re

# revision identifiers, used by Alembic.
revision = '37ae975212e2'
down_revision = '9f3eb0cfb36a'
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    # Create categories table first (check if exists)
    connection = op.get_bind()
    inspector = sa.inspect(connection)
    existing_tables = inspector.get_table_names()
    
    if 'categories' not in existing_tables:
        op.create_table('categories',
            sa.Column('id', sa.Integer(), nullable=False),
            sa.Column('name', sa.String(length=100), nullable=False),
            sa.Column('slug', sa.String(length=100), nullable=False),
            sa.Column('description', sa.String(length=500), nullable=True),
            sa.Column('created_at', sa.DateTime(), nullable=False),
            sa.PrimaryKeyConstraint('id'),
            sa.UniqueConstraint('name'),
            sa.UniqueConstraint('slug')
        )
        op.create_index(op.f('ix_categories_slug'), 'categories', ['slug'], unique=False)
    
    # Create ArticleStatus enum type (check if exists)
    connection = op.get_bind()
    result = connection.execute(sa.text("""
        SELECT EXISTS (
            SELECT 1 FROM pg_type WHERE typname = 'articlestatus'
        )
    """))
    enum_exists = result.scalar()
    
    if not enum_exists:
        article_status_enum = postgresql.ENUM('DRAFT', 'PUBLISHED', 'ARCHIVED', name='articlestatus', create_type=True)
        article_status_enum.create(connection)
    
    # Get existing columns to avoid duplicates
    inspector = sa.inspect(connection)
    existing_columns = [col['name'] for col in inspector.get_columns('articles')]
    
    # Add columns as nullable first (only if they don't exist)
    with op.batch_alter_table('articles', schema=None) as batch_op:
        if 'subtitle' not in existing_columns:
            batch_op.add_column(sa.Column('subtitle', sa.String(length=500), nullable=True))
        if 'read_time' not in existing_columns:
            batch_op.add_column(sa.Column('read_time', sa.Integer(), nullable=True))
        if 'published_at' not in existing_columns:
            batch_op.add_column(sa.Column('published_at', sa.DateTime(), nullable=True))
        if 'category_id' not in existing_columns:
            batch_op.add_column(sa.Column('category_id', sa.Integer(), nullable=True))
        if 'tags' not in existing_columns:
            batch_op.add_column(sa.Column('tags', postgresql.ARRAY(sa.String()), nullable=True))
        if 'slug' not in existing_columns:
            batch_op.add_column(sa.Column('slug', sa.String(length=500), nullable=True))  # Start as nullable
        if 'meta_title' not in existing_columns:
            batch_op.add_column(sa.Column('meta_title', sa.String(length=500), nullable=True))
        if 'meta_description' not in existing_columns:
            batch_op.add_column(sa.Column('meta_description', sa.String(length=1000), nullable=True))
        if 'og_image' not in existing_columns:
            batch_op.add_column(sa.Column('og_image', sa.String(length=500), nullable=True))
        if 'author_id' not in existing_columns:
            batch_op.add_column(sa.Column('author_id', sa.Integer(), nullable=True))
        if 'status' not in existing_columns:
            batch_op.add_column(sa.Column('status', postgresql.ENUM('DRAFT', 'PUBLISHED', 'ARCHIVED', name='articlestatus'), nullable=True))  # Start as nullable
        if 'views_count' not in existing_columns:
            batch_op.add_column(sa.Column('views_count', sa.Integer(), nullable=True))  # Start as nullable
        if 'updated_at' not in existing_columns:
            batch_op.add_column(sa.Column('updated_at', sa.DateTime(), nullable=True))  # Start as nullable
    
    # Generate slugs and set defaults for existing articles (only if slug column exists)
    connection = op.get_bind()
    inspector = sa.inspect(connection)
    existing_columns = [col['name'] for col in inspector.get_columns('articles')]
    
    if 'slug' in existing_columns:
        articles = connection.execute(sa.text("SELECT id, title FROM articles WHERE slug IS NULL"))
    
    for article in articles:
        article_id = article[0]
        title = article[1] or f'article-{article_id}'
        
        # Generate slug from title (same logic as in routes.py)
        slug = title.lower()
        slug = re.sub(r'[^\w\s-]', '', slug)
        slug = re.sub(r'[-\s]+', '-', slug)
        slug = slug.strip('-')
        if not slug:
            slug = f'article-{article_id}'
        
        # Ensure uniqueness
        counter = 1
        base_slug = slug
        while True:
            existing = connection.execute(
                sa.text("SELECT id FROM articles WHERE slug = :slug AND id != :id"),
                {'slug': slug, 'id': article_id}
            ).fetchone()
            if not existing:
                break
            slug = f"{base_slug}-{counter}"
            counter += 1
        
        # Update article with generated slug and defaults
        connection.execute(
            sa.text("""
                UPDATE articles 
                SET slug = :slug, 
                    status = 'DRAFT'::articlestatus, 
                    views_count = 0, 
                    updated_at = created_at,
                    author_id = 1
                WHERE id = :id
            """),
            {'slug': slug, 'id': article_id}
        )
    
    # Now make required columns NOT NULL (only if they exist and are nullable)
    inspector = sa.inspect(connection)
    existing_columns = [col['name'] for col in inspector.get_columns('articles')]
    existing_indexes = [idx['name'] for idx in inspector.get_indexes('articles')]
    
    with op.batch_alter_table('articles', schema=None) as batch_op:
        # Check if columns exist and are nullable before altering
        if 'slug' in existing_columns:
            # Check if column is nullable
            slug_col = next((col for col in inspector.get_columns('articles') if col['name'] == 'slug'), None)
            if slug_col and slug_col['nullable']:
                batch_op.alter_column('slug', nullable=False)
        if 'status' in existing_columns:
            status_col = next((col for col in inspector.get_columns('articles') if col['name'] == 'status'), None)
            if status_col and status_col['nullable']:
                batch_op.alter_column('status', nullable=False)
        if 'views_count' in existing_columns:
            views_col = next((col for col in inspector.get_columns('articles') if col['name'] == 'views_count'), None)
            if views_col and views_col['nullable']:
                batch_op.alter_column('views_count', nullable=False)
        if 'updated_at' in existing_columns:
            updated_col = next((col for col in inspector.get_columns('articles') if col['name'] == 'updated_at'), None)
            if updated_col and updated_col['nullable']:
                batch_op.alter_column('updated_at', nullable=False)
        
        # Create indexes (only if they don't exist)
        if 'idx_article_published_at' not in existing_indexes and 'published_at' in existing_columns:
            batch_op.create_index('idx_article_published_at', ['published_at'], unique=False)
        if 'idx_article_slug' not in existing_indexes and 'slug' in existing_columns:
            batch_op.create_index('idx_article_slug', ['slug'], unique=False)
        if 'idx_article_status' not in existing_indexes and 'status' in existing_columns:
            batch_op.create_index('idx_article_status', ['status'], unique=False)
        if 'ix_articles_slug' not in existing_indexes and 'slug' in existing_columns:
            batch_op.create_index(batch_op.f('ix_articles_slug'), ['slug'], unique=True)
        
        # Create foreign key (only if category_id exists and constraint doesn't exist)
        if 'category_id' in existing_columns:
            existing_fks = [fk['name'] for fk in inspector.get_foreign_keys('articles')]
            category_fk_exists = any(fk for fk in inspector.get_foreign_keys('articles') 
                                   if 'category_id' in [col['name'] for col in fk['constrained_columns']])
            if not category_fk_exists:
                batch_op.create_foreign_key(None, 'categories', ['category_id'], ['id'])

    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('articles', schema=None) as batch_op:
        batch_op.drop_constraint(None, type_='foreignkey')
        batch_op.drop_index(batch_op.f('ix_articles_slug'))
        batch_op.drop_index('idx_article_status')
        batch_op.drop_index('idx_article_slug')
        batch_op.drop_index('idx_article_published_at')
        batch_op.drop_column('updated_at')
        batch_op.drop_column('views_count')
        batch_op.drop_column('status')
        batch_op.drop_column('author_id')
        batch_op.drop_column('og_image')
        batch_op.drop_column('meta_description')
        batch_op.drop_column('meta_title')
        batch_op.drop_column('slug')
        batch_op.drop_column('tags')
        batch_op.drop_column('category_id')
        batch_op.drop_column('published_at')
        batch_op.drop_column('read_time')
        batch_op.drop_column('subtitle')
    
    # Drop enum type
    op.execute('DROP TYPE IF EXISTS articlestatus')
    
    # Drop categories table
    op.drop_index(op.f('ix_categories_slug'), table_name='categories')
    op.drop_table('categories')

    # ### end Alembic commands ###
